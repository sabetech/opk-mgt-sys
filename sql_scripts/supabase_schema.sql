-- Create the products table
CREATE TABLE products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  sku_name TEXT NOT NULL,
  returnable BOOLEAN NOT NULL DEFAULT FALSE,
  code_name TEXT,
  wholesale_price DECIMAL(10, 2),
  retail_price DECIMAL(10, 2),
  deleted_at TIMESTAMP WITH TIME ZONE
);

-- Basic RLS policies (optional but recommended)
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

-- Allow read access to everyone
CREATE POLICY "Allow public read access" ON products
  FOR SELECT USING (true);

-- Allow authenticated users (or service role) to insert/update/delete
-- Since we are using anon key for import script which might need insert access if RLS is on,
-- we either need to turn off RLS or add a policy for anon insert (not recommended for prod)
-- OR just tell the user to run the script.
-- ACTUALLY: The user provided ANON key. Anon key cannot insert if RLS is enabled and no policy allows it.
-- For the import script to work with ANON key, we need a policy allowing INSERT for anon, OR we tell the user to disable RLS for now.

-- Let's create a policy ensuring we can insert data.
-- Since this is an internal tool usage initially, let's allow inserts for now, OR better, 
-- we will just instruct the user to run the script.
-- Wait, I will use the anon key in the script.
-- Does the user have a logged in user? No.
-- So I should just DISABLE RLS for the import or add an INSERT policy for anon.
-- Let's add an insert policy for public for now to ease the import, then they can remove it.

CREATE POLICY "Allow public insert" ON products
  FOR INSERT WITH CHECK (true);

-- Create customer_types table
CREATE TABLE customer_types (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);

ALTER TABLE customer_types ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access" ON customer_types FOR SELECT USING (true);

-- Seed customer_types
INSERT INTO customer_types (name) VALUES 
('Retailer'), 
('Wholesaler'), 
('Retailer (VSE)');

-- Create customers table
CREATE TABLE customers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  name TEXT NOT NULL,
  phone TEXT,
  type_id BIGINT REFERENCES customer_types(id),
  balance INTEGER DEFAULT 0,
  deleted_at TIMESTAMP WITH TIME ZONE
);

ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access" ON customers FOR SELECT USING (true);
CREATE POLICY "Allow public insert" ON customers FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow public update" ON customers FOR UPDATE USING (true);

-- Create the empties table to track crates with empty bottles
CREATE TABLE empties (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT REFERENCES products(id) NOT NULL UNIQUE,
  quantity_in_trade INTEGER DEFAULT 0 NOT NULL,
  quantity_on_ground INTEGER DEFAULT 0 NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Function to handle updated_at automatically
CREATE OR REPLACE FUNCTION handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at_empties
BEFORE UPDATE ON empties
FOR EACH ROW
EXECUTE FUNCTION handle_updated_at();

-- RLS Policies for empties
ALTER TABLE empties ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public read access" ON empties FOR SELECT USING (true);
CREATE POLICY "Allow public insert" ON empties FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow public update" ON empties FOR UPDATE USING (true);

-- ##################################################################
-- INVENTORY RECEIVABLES & WAREHOUSE STOCK
-- ##################################################################

-- Header table for receivables
CREATE TABLE inventory_receivables (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL,
  purchase_order_number TEXT NOT NULL,
  received_by TEXT NOT NULL,
  delivered_by TEXT NOT NULL,
  vehicle_no TEXT NOT NULL,
  num_of_pallets INTEGER DEFAULT 0,
  num_of_pcs INTEGER DEFAULT 0,
  purchase_order_img_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Item details for each receivable
CREATE TABLE inventory_receivable_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  receivable_id BIGINT REFERENCES inventory_receivables(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES products(id),
  qty INTEGER NOT NULL,
  date DATE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Centralized stock table
CREATE TABLE warehouse_stock (
  product_id BIGINT REFERENCES products(id) PRIMARY KEY,
  quantity INTEGER DEFAULT 0 NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Trigger to handle updated_at for receivables
CREATE TRIGGER set_updated_at_receivables
BEFORE UPDATE ON inventory_receivables
FOR EACH ROW
EXECUTE FUNCTION handle_updated_at();

-- Trigger to update warehouse_stock automatically when items are received
CREATE OR REPLACE FUNCTION update_stock_after_receivable()
RETURNS TRIGGER AS $$
BEGIN
  -- Update stock
  INSERT INTO warehouse_stock (product_id, quantity)
  VALUES (NEW.product_id, NEW.qty)
  ON CONFLICT (product_id)
  DO UPDATE SET 
    quantity = warehouse_stock.quantity + EXCLUDED.quantity,
    updated_at = NOW();

  -- Log movement
  INSERT INTO inventory_logs (product_id, type, quantity, reference_id, reference_table, description)
  VALUES (NEW.product_id, 'supplier_receipt', NEW.qty, NEW.id, 'inventory_receivable_items', 'Received from Supplier');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_stock_after_receivable
AFTER INSERT ON inventory_receivable_items
FOR EACH ROW
EXECUTE FUNCTION update_stock_after_receivable();

-- RLS Policies
ALTER TABLE inventory_receivables ENABLE ROW LEVEL SECURITY;
ALTER TABLE inventory_receivable_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE warehouse_stock ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public access" ON inventory_receivables FOR ALL USING (true);
CREATE POLICY "Allow public access" ON inventory_receivable_items FOR ALL USING (true);
CREATE POLICY "Allow public access" ON warehouse_stock FOR ALL USING (true);

-- ##################################################################
-- EMPTIES LOGGING
-- ##################################################################

-- Create activity type enum
DO $$ BEGIN
    CREATE TYPE empties_activity_type AS ENUM (
      'customer_empties_return',
      'empties_to_supplier',
      'customer_purchase'
    );
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Table for tracking empties activities
CREATE TABLE IF NOT EXISTS empties_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  total_quantity INTEGER NOT NULL DEFAULT 0,
  activity empties_activity_type NOT NULL,
  customer_id BIGINT REFERENCES customers(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Breakdown of products and quantities for each log entry
CREATE TABLE IF NOT EXISTS empties_log_detail (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  log_id BIGINT REFERENCES empties_log(id) ON DELETE CASCADE NOT NULL,
  product_id BIGINT REFERENCES products(id) NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- RLS Policies
ALTER TABLE empties_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE empties_log_detail ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public access" ON empties_log FOR ALL USING (true);
CREATE POLICY "Allow public access" ON empties_log_detail FOR ALL USING (true);

-- Function to handle customer balance updates
CREATE OR REPLACE FUNCTION update_customer_empties_balance()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.customer_id IS NOT NULL THEN
        IF NEW.activity = 'customer_purchase' THEN
            UPDATE customers
            SET balance = balance + NEW.total_quantity
            WHERE id = NEW.customer_id;
        ELSIF NEW.activity = 'customer_empties_return' THEN
            UPDATE customers
            SET balance = balance - NEW.total_quantity
            WHERE id = NEW.customer_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to handle updated_at automatically
CREATE TRIGGER set_updated_at_empties_log
BEFORE UPDATE ON empties_log
FOR EACH ROW
EXECUTE FUNCTION handle_updated_at();

-- Trigger to update customer balance automatically
CREATE TRIGGER trigger_update_customer_empties_balance
AFTER INSERT ON empties_log
FOR EACH ROW
EXECUTE FUNCTION update_customer_empties_balance();
