-- Create order_status enum
DO $$ BEGIN
    CREATE TYPE order_status AS ENUM ('pending', 'approved', 'cancelled');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- 1. Create order_types table
CREATE TABLE IF NOT EXISTS order_types (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Seed order_types
INSERT INTO order_types (name) 
VALUES ('sale'), ('vse'), ('promo'), ('protocol')
ON CONFLICT (name) DO NOTHING;

-- 2. Create orders table
CREATE TABLE IF NOT EXISTS orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id BIGINT REFERENCES customers(id),
    total_amount DECIMAL(12, 2) NOT NULL DEFAULT 0,
    amount_tendered DECIMAL(12, 2) NOT NULL DEFAULT 0,
    payment_type TEXT,
    transaction_id TEXT,
    order_type_id BIGINT REFERENCES order_types(id),
    date_time TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    status order_status NOT NULL DEFAULT 'pending',
    user_id UUID DEFAULT auth.uid(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    deleted_at TIMESTAMP WITH TIME ZONE
);

-- 3. Create sales (order items) table
CREATE TABLE IF NOT EXISTS sales (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES orders(id) ON DELETE CASCADE,
    product_id BIGINT REFERENCES products(id),
    discount DECIMAL(12, 2) DEFAULT 0,
    quantity INTEGER NOT NULL DEFAULT 1,
    unit_price DECIMAL(12, 2) NOT NULL DEFAULT 0,
    sub_total DECIMAL(12, 2) NOT NULL DEFAULT 0,
    user_id UUID DEFAULT auth.uid(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    deleted_at TIMESTAMP WITH TIME ZONE
);

-- Triggers for updated_at (using existing handle_updated_at function if available)
-- If handle_updated_at is not defined in the current context, we define it or use the one from schema.
DO $$ BEGIN
    CREATE TRIGGER set_updated_at_orders
    BEFORE UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION handle_updated_at();

    CREATE TRIGGER set_updated_at_sales
    BEFORE UPDATE ON sales
    FOR EACH ROW
    EXECUTE FUNCTION handle_updated_at();
EXCEPTION
    WHEN undefined_function THEN
        -- Fallback: define function if missing
        CREATE OR REPLACE FUNCTION handle_updated_at()
        RETURNS TRIGGER AS $inner$
        BEGIN
            NEW.updated_at = NOW();
            RETURN NEW;
        END;
        $inner$ LANGUAGE plpgsql;
        
        -- Try again
        CREATE TRIGGER set_updated_at_orders
        BEFORE UPDATE ON orders
        FOR EACH ROW
        EXECUTE FUNCTION handle_updated_at();

        CREATE TRIGGER set_updated_at_sales
        BEFORE UPDATE ON sales
        FOR EACH ROW
        EXECUTE FUNCTION handle_updated_at();
END $$;

-- RLS Policies
ALTER TABLE order_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE sales ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public read access" ON order_types FOR SELECT USING (true);
CREATE POLICY "Allow public access" ON orders FOR ALL USING (true);
CREATE POLICY "Allow public access" ON sales FOR ALL USING (true);
